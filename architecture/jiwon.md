## 📌 CPU와 명령어 처리

### ARCH-001

CPU의 구조와 주요 구성 요소(ALU, 제어 유닛, 레지스터)에 대해 설명해주세요.

> CPU : 중앙 처리 장치(Central Processing Unit). 명령어를 해석하고 실행하는 컴퓨터의 핵심 처리 장치

```
          ┌────────────────────────┐
          │       제어 유닛 (CU)     │
          │  - 명령어 가져오기(Fetch)  │
          │  - 명령 해석(Decode)     │
          │  - 각 장치 제어           │
          └────────────┬───────────┘
                       │ 제어 신호
                       ▼
         ┌─────────────────────────┐
         │        ALU              │
         │  - 산술/논리 연산 수행      │
         └───────▲─────────────────┘
                 │ 연산 데이터
                 │
        ┌───────────────────────────┐
        │         레지스터 그룹        │
        │ - 초고속 데이터 저장          │
        └───────────────────────────┘
```

<CPU의 주요 구성 요소>

1. ALU (Arithmetic Logic Unit, 산술 논리 장치)
   - 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR 등), 비교 연산(>, ==, <), 비트 연산(shift, rotate)을 수행하는 장치
     - cf) rotate : 시프트 수행 시, 밀려난 비트를 반대쪽 끝에 다시 넣어주는 연산
   - CPU 내부에서 실제 계산 작업을 담당
2. 제어 유닛(Control Unit)
   - CPU의 작동을 제어하고 조정하는 역할
   - 메모리에서 명령어를 가져오고(fetch) 해석하여(decode) ALU와 레지스터 등 다른 구성 요소에 신호를 보내 작업을 수행하도록 지시(execute)
   - 명령어 사이클(Instruction Cycle)을 관리 (Fetch, Decode, Execute 단계)
3. 레지스터(Register)
    - CPU 내부에 위치한 고속 기억장치
    - 데이터, 명령어, 주소 등을 **일시적으로** 저장
    - 용량이 아주 작지만 빠르게 접근 가능(cpu 내부에 있으므로)
      - 메모리 접근 없이 바로 연산 가능 -> 성능 향상
    - 종류
      1. 범용 레지스터: 데이터와 주소를 모두 저장할 수 있음
      2. 메모리 주소 레지스터(MAR): CPU가 데이터를 읽거나 쓰려는 메모리 주소를 일시적으로 저장 ("어디")
      3. 메모리 버퍼 레지스터(MBR): 메모리에서 읽어온 데이터나 메모리에 쓸 데이터를 일시적으로 저장 ("무엇")
           - 해당 레지스터에 배치된 명령은 명령어 레지스터(IR)로 전송되며, 데이터의 경우 ALU로 전송되어 연산에 사용됨
      4. 명령어 레지스터(IR): 주기억장치에서 수행할 명령어를 가져와서 저장. 제어장치의 지시를 받아 명령어를 해석하고 실행
      5. 누산기(Accumulator)
           - ALU 내부에 위치
           - ALU의 산술 및 논리 연산 중에 사용됨
           - 제어 장치는 산술 또는 논리 동작을 위해 주기억장치에서 가져온 데이터를 누산기 레지스터에 저장
           - 이 레지스터에는 주로 시스템에 사용될 초기 데이터, 중간 결과 및 죄종 동작 결과가 보관되며 최종 결과는 MBR을 통해 주기억장치로 전송됨
      6. 플래그 레지스터: 연산 결과의 상태(예: 0, 음수, 오버플로우 등)를 나타내는 비트를 저장
      7. 프로그램 카운터(PC): 다음에 실행할 명령어의 주소를 일시적으로 저장

### ARCH-002

명령어 사이클(Instruction Cycle)의 단계(Fetch, Decode, Execute)에 대해 설명해주세요.

1. Fetch
     - 메모리에서 실행할 명령어를 IR에 가져오는 단계
     - PC에 있는 주소를 MAR에 복사
     - MAR의 주소를 사용하여 메모리에서 명령어를 읽어 MBR에 저장
     - MBR의 명령어를 IR로 복사
     - PC를 증가시켜 다음 명령어의 주소를 가리키도록 설정
2. Decode
      - IR에 저장된 명령어를 CPU가 해석하는 단계
      - 제어 유닛이 명령어의 오퍼코드(연산 코드)를 분석하여 어떤 연산을 수행할지 결정
      - 필요한 레지스터가 어떤 것인지 파악
      - 무슨 명령인지 판단하여 필요한 제어 신호를 준비하는 단계
3. Execute
   - 해석된 명령어를 실제로 수행하는 단계
   - ALU 연산 수행
   - 레지스터 간 데이터 이동
   - 메모리 접근(읽기/쓰기)
   - 제어 흐름 변경(분기, 점프 등)
   - 시스템 호출 수행 등
   - 실행 후에는 다시 PC를 보고 다음 명령어 Fetch 단계로 돌아가서 사이클을 반복.

### ARCH-003
파이프라이닝(Pipelining)이 무엇이고, 어떻게 CPU 성능을 향상시키나요?

> Pipelining : Fetch -> Decode -> Execute 단계를 병렬화하여 CPU 서리량을 높이는 방법

- CPU가 한 명령어를 끝낼 때까지 기다리지 않고, 다음 명령어를 미리 시작하는 방식
- 한 명령어가 끝나는 데에 사이클이 소모되는 동안, 여러 가지의 태스크를 처리할 수 있기 때문에 효과적

<단점>

- 처리 시간이 일정하지 않고, 처리 단계가 균등하지 않으면 문제가 발생할 수 있음(Hazard)

### ARCH-004
파이프라인 해저드(Pipeline Hazard)의 종류와 해결 방법에 대해 설명해주세요.

<해저드 종류>

1. 구조적 해저드(Structural Hazard)
   - 하드웨어 자원이 부족하여 발생
   - 예) 하나의 메모리 버스가 명령어와 데이터를 동시에 처리할 수 없는 경우
2. 데이터 해저드(Data Hazard)
   - 이전 명령어의 결과가 다음 명령어에서 필요하기 때문에 파이프라인이 지연되어야 하는 경우 발생
   - 예) 명령어1이 레지스터 A에 값을 쓰고, 명령어2가 그 값을 읽으려 할 때
3. 제어 해저드(Control Hazard)
   - 분기 명령어로 인해 파이프라인이 기대와 다르게 동작할 때 발생
   - 예) 분기 명령어가 실행되기 전에 다음 명령어를 가져오면 잘못된 명령어를 실행할 수 있음
   - 보완책 :
     - 지연 : 적절한 결과값이 나올 때까지 해당 작업을 반복해서 수행. 다른 작업의 지연을 초래한다는 단점이 있음
     - 예측 : 분기 예측(Branch Prediction) 기법을 사용하여 분기 결과를 미리 예측하고, 예측이 맞으면 성능 향상, 틀리면 파이프라인을 플러시하고 다시 시작

### ARCH-005
분기 예측(Branch Prediction)이 무엇이고 왜 중요한가요?

> Branch Prediction : 분기 명령어의 결과를 미리 예측하여 파이프라인의 효율성을 높이는 기법

- 조건의 결과를 기다리지 않고 미리 다음 명령어를 가져와서 파이프라인을 계속 유지하기 위해 분기 예측을 사용
- 하지만 분기 예측이 실패할 시, 파이프라인을 플러시하고 다시 시작해야 하므로 성능 저하가 발생할 수 있기에 예측 전략이 중요

<분기 예측 종류>

1. 정적 예측(Static Prediction)
   - 고정된 규칙에 따라 분기를 예측
   - 예) 항상 분기하지 않는다고 가정하거나, 특정 분기는 항상 수행한다고 가정
2. 동적 예측(Dynamic Prediction)
   - 실행 중인 프로그램의 실제 동작을 기반으로 분기를 예측
   - CPU가 과거 실행 기록을 학습해서 예측하는 방식
   - 성능이 훨씬 좋지만 알고리즘 복잡도와 하드웨어 비용, Latency가 증가
   - 예) 2비트 예측기, 히스토리 기반 예측 등
   - 종류
     1. 1비트 예측기 : 가장 단순한 형태로, 이전 분기 결과에 따라 다음 분기를 예측
     2. 2비트 예측기 : 1비트 예측기의 단점을 보완. 두 번의 연속된 결과를 기반으로 예측
     3. 2-level prediction : 두 단계의 히스토리를 사용하여 더 정교한 예측 수행
        1. 글로벌 히스토리 기반 예측기 : 어떤 branch와 연관있을 수 있는 **모든** 분기 명령어의 과거 결과를 기반으로 예측
        2. 로컬 히스토리 기반 예측기 : 어떤 branch와 **같은** 분기 명령어의 과거 결과를 기반으로 예측

자세한 구현 방법은 [해당 블로그](https://m.blog.naver.com/ektjf731/223053617175) 참고를 강추!

### ARCH-006

Out-of-Order Execution이 무엇이고, 어떤 이점이 있나요?

> Out-of-Order Execution : 명령어를 프로그램 **순서와 상관없이 실행**하여 CPU 자원을 효율적으로 활용하는 기법

- 프로그램 순서는 유지하되, cpu 내부에서 실행 순서만 바꾸는 방식

<장점>

- 메모리 지연을 숨길 수 있다
  - 숨긴다 : CPU가 기다리지 않고 다른 명령어를 실행할 수 있도록 하여 같은 지연 시간이더라도 더 많은 작업을 수행
- 병렬성 증가
- 자원 활용 극대화

<단점>

- 하드웨어 복잡성 증가(비용 증가)
- 전력 소모 및 발열 증가
- 디버깅 분석 난이도 증가 -> 실행 순서가 복잡해지기 때문
- 성능은 올리지만, 실제 지연 시간 자체를 줄이지는 못함(근본적인 해결책은 아님)
- 이를 활용한 [보안 취약점](https://library.gabia.com/contents/infrahosting/5412/) 발생 가능 (Spectre, Meltdown 등)
  - 요약하면, 예외가 발생하기 전에 CPU가 미리 실행한 명령어의 결과를 통해 민감한 데이터를 유출할 수 있다는 것

### ARCH-007

CISC와 RISC 아키텍처의 차이점에 대해 설명해주세요.

> CISC(Complex Instruction Set Computer) : 적은 수의 어셈블리 명령으로도 복잡한 작업을 수행할 수 있도록 "명령어 하나가 여러 일을 동시에 처리하는 구조"

- 예) Intel x86, AMD64
- 가변 길이 명령어를 사용하여 복잡한 작업을 수행
- Hardware가 이 명령어를 해석하려면 복잡한 디코더가 필요하며, 설계 및 구현이 어려워질 수 있음
- `ADD R1, R2, [MEM]` 같이 명령어 하나로 메모리에서 값을 읽어와서 더하고 결과를 다시 메모리에 저장 -> 메모리 읽기 + ALU 연산 + 메모리 쓰기를 한 번에 처리 가능

<장점>

- 복잡한 명령어 하나로 여러 작업을 처리할 수 있어 코드 크기가 작아짐
- 오래된 소프트웨어와 호환성 높음

<단점>

- 명령어 해석이 복잡하여 CPU 설계가 어려워짐
- 파이프라이닝 및 병렬 처리에 불리할 수 있음
- 명령어 실행 시간이 일정하지 않음

> RISC(Reduced Instruction Set Computer) : 모든 명령어를 단순하고 규칙적으로 만들어 "짧고 단순한 명령어를 여러 개 조합해서 작업을 수행하는 구조"

- 예) ARM, MIPS, RISC-V
- 고정 길이 명령어를 여러개 사용하여 단순한 작업을 수행
- 하드웨어 설계가 간단하고 효율적이며, 성능 향상에 유리
- 메모리 접근은 Load/Store 명령어만 담당하며, 나머지 연산은 레지스터 간에만 수행

<장점>

- 명령어 해석이 단순하여 CPU 설계가 쉬워짐
- 파이프라이닝 및 병렬 처리에 유리
- 명령어 실행 시간이 일정하여 예측 가능
- 전력 효율성이 높아 모바일 및 임베디드 시스템에 적합

<단점>

- 복잡한 작업을 수행하려면 더 많은 명령어가 필요하여 코드 크기가 커질 수 있음
- 일부 복잡한 명령어를 직접 지원하지 않아 소프트웨어에서 더 많은 작업이 필요할 수 있음

### ARCH-008

x86과 ARM 아키텍처의 차이점은 무엇인가요?

> x86 : 인텔이 개발한 CISC 아키텍처 기반의 명령어 집합 구조

- 주로 데스크탑, 노트북, 서버 등 고성능 컴퓨팅에 사용

> ARM : ARM 홀딩스가 개발한 RISC 아키텍처 기반의 명령어 집합 구조

- 주로 모바일 기기, 임베디드 시스템 등 저전력, 고효율 컴퓨팅에 사용

---

References :

[레지스터 종류와 특징(MAR, MBR, PC, IR, AC, SCR, FR, DR)](https://blog.naver.com/techref/222249216316)

[[컴퓨터구조]Lecture 18 : 분기 예측 Ⅱ](https://m.blog.naver.com/ektjf731/223053617175)

[[특별기고] CPU 취약점 종합보고서 ①: 취약점 기본원리](https://library.gabia.com/contents/infrahosting/5412/)
